{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OakVar: Genomic Variant Analysis Platform Annotate genomic variants with diverse annotation sources. Make databases of annotated variants. Query annotated variants with filter sets. Make reports in diverse formats. Visualize annotated variants with graphical user interface. Works via CLI and GUI. Easily develop, run, and distribute CLI and GUI genomics apps. OakVar acts as an operating system for genomics apps. Connect genomic data to AI/ML models. OakVar is a genomic variant interpretation platform. Genomic variants can be annotated with diverse annotation sources, stored in databases, queried with filter sets, written to reports in diverse formats, and visualized with graphical user interfaces. Furthermore, OakVar supports command-line and graphical user interface apps which use the annotated variant data generated by OakVar, just like an operating system supports applications on it.","title":"Home"},{"location":"#oakvar-genomic-variant-analysis-platform","text":"Annotate genomic variants with diverse annotation sources. Make databases of annotated variants. Query annotated variants with filter sets. Make reports in diverse formats. Visualize annotated variants with graphical user interface. Works via CLI and GUI. Easily develop, run, and distribute CLI and GUI genomics apps. OakVar acts as an operating system for genomics apps. Connect genomic data to AI/ML models. OakVar is a genomic variant interpretation platform. Genomic variants can be annotated with diverse annotation sources, stored in databases, queried with filter sets, written to reports in diverse formats, and visualized with graphical user interfaces. Furthermore, OakVar supports command-line and graphical user interface apps which use the annotated variant data generated by OakVar, just like an operating system supports applications on it.","title":"OakVar: Genomic Variant Analysis Platform"},{"location":"cli/","text":"CLI Commands Setup ov system setup Run an analysis job ov run Create annotation reports ov report Launch a GUI server ov gui Manage modules List modules ov module ls Install modules ov module install Uninstall modules ov module uninstall Install system modules ov module installbase Update modules ov module update Get information on modules ov module info Manage store accounts Create a store account ov store account create Delete a store account ov store account delete Change a store account password ov store account change Check if logged in on the OakVar store ov store account check Log in on the OakVar store ov store account login Log out from the OakVar store ov store account logout Reset the password of a store account ov store account reset Publish modules Pack a module for registering at the OakVar store ov module pack Register a module at the OakVar store ov store register Manage configuration Manage modules directory ov system md Show system configuration ov config system Show user configuration ov config user Test modules ov util test Utilities Create an example input file ov new exampleinput Create an annotation module template ov new annotator Merge analysis result database files ov util mergesqlite Filter analysis result database files ov util filtersqlite Show analysis result database file information ov util showsqliteinfo","title":"Command-line interface"},{"location":"cli/#cli-commands","text":"","title":"CLI Commands"},{"location":"cli/#setup","text":"ov system setup","title":"Setup"},{"location":"cli/#run-an-analysis-job","text":"ov run","title":"Run an analysis job"},{"location":"cli/#create-annotation-reports","text":"ov report","title":"Create annotation reports"},{"location":"cli/#launch-a-gui-server","text":"ov gui","title":"Launch a GUI server"},{"location":"cli/#manage-modules","text":"","title":"Manage modules"},{"location":"cli/#list-modules","text":"ov module ls","title":"List modules"},{"location":"cli/#install-modules","text":"ov module install","title":"Install modules"},{"location":"cli/#uninstall-modules","text":"ov module uninstall","title":"Uninstall modules"},{"location":"cli/#install-system-modules","text":"ov module installbase","title":"Install system modules"},{"location":"cli/#update-modules","text":"ov module update","title":"Update modules"},{"location":"cli/#get-information-on-modules","text":"ov module info","title":"Get information on modules"},{"location":"cli/#manage-store-accounts","text":"","title":"Manage store accounts"},{"location":"cli/#create-a-store-account","text":"ov store account create","title":"Create a store account"},{"location":"cli/#delete-a-store-account","text":"ov store account delete","title":"Delete a store account"},{"location":"cli/#change-a-store-account-password","text":"ov store account change","title":"Change a store account password"},{"location":"cli/#check-if-logged-in-on-the-oakvar-store","text":"ov store account check","title":"Check if logged in on the OakVar store"},{"location":"cli/#log-in-on-the-oakvar-store","text":"ov store account login","title":"Log in on the OakVar store"},{"location":"cli/#log-out-from-the-oakvar-store","text":"ov store account logout","title":"Log out from the OakVar store"},{"location":"cli/#reset-the-password-of-a-store-account","text":"ov store account reset","title":"Reset the password of a store account"},{"location":"cli/#publish-modules","text":"","title":"Publish modules"},{"location":"cli/#pack-a-module-for-registering-at-the-oakvar-store","text":"ov module pack","title":"Pack a module for registering at the OakVar store"},{"location":"cli/#register-a-module-at-the-oakvar-store","text":"ov store register","title":"Register a module at the OakVar store"},{"location":"cli/#manage-configuration","text":"","title":"Manage configuration"},{"location":"cli/#manage-modules-directory","text":"ov system md","title":"Manage modules directory"},{"location":"cli/#show-system-configuration","text":"ov config system","title":"Show system configuration"},{"location":"cli/#show-user-configuration","text":"ov config user","title":"Show user configuration"},{"location":"cli/#test-modules","text":"ov util test","title":"Test modules"},{"location":"cli/#utilities","text":"","title":"Utilities"},{"location":"cli/#create-an-example-input-file","text":"ov new exampleinput","title":"Create an example input file"},{"location":"cli/#create-an-annotation-module-template","text":"ov new annotator","title":"Create an annotation module template"},{"location":"cli/#merge-analysis-result-database-files","text":"ov util mergesqlite","title":"Merge analysis result database files"},{"location":"cli/#filter-analysis-result-database-files","text":"ov util filtersqlite","title":"Filter analysis result database files"},{"location":"cli/#show-analysis-result-database-file-information","text":"ov util showsqliteinfo","title":"Show analysis result database file information"},{"location":"devguide_debugging/","text":"Entrypoints Command Entrypoint ov oakvar/__main__.py ov run oakvar/cli/run.py ov report oakvar/cli/report.py ov gui oakvar/cli/gui.py oakvar/__main__.py is intentional, to make python -m oakvar style of use possible. Base classes OakVar modules inherit one of OakVar base module classes. Converters, mappers, annotators, postaggregators, and reporters have different base module classes. Type Module Class converter oakvar/base/converter.py BaseConverter mapper oakvar/base/mapper.py BaseMapper annotator oakvar/base/annotator.py BaseAnnotator postaggregator oakvar/base/postaggregator.py BasePostAggregator reporter oakvar/cli/report.py BaseReporter common oakvar/base/commonmodule.py BaseCommonModule To develop a new OakVar module, it should inherit one of these base classes. For example, an annotator module's class definition should be: from oakvar import BaseAnnotator class Annotator(BaseAnnotator):","title":"Debugging"},{"location":"devguide_debugging/#entrypoints","text":"Command Entrypoint ov oakvar/__main__.py ov run oakvar/cli/run.py ov report oakvar/cli/report.py ov gui oakvar/cli/gui.py oakvar/__main__.py is intentional, to make python -m oakvar style of use possible.","title":"Entrypoints"},{"location":"devguide_debugging/#base-classes","text":"OakVar modules inherit one of OakVar base module classes. Converters, mappers, annotators, postaggregators, and reporters have different base module classes. Type Module Class converter oakvar/base/converter.py BaseConverter mapper oakvar/base/mapper.py BaseMapper annotator oakvar/base/annotator.py BaseAnnotator postaggregator oakvar/base/postaggregator.py BasePostAggregator reporter oakvar/cli/report.py BaseReporter common oakvar/base/commonmodule.py BaseCommonModule To develop a new OakVar module, it should inherit one of these base classes. For example, an annotator module's class definition should be: from oakvar import BaseAnnotator class Annotator(BaseAnnotator):","title":"Base classes"},{"location":"devguide_modules/","text":"OakVar's functionalities are mostly performed by Python modules. OakVar orchestrates their execution as well as their management. To understand OakVar's modules, let's first see which modules are already installed in the system. ov module ls This will show a list of modules installed in the system. These modules are stored under OakVar modules directory , which can be found with ov system md Inside the modules directory , there are subdirectories such as the following. annotators commons converters mappers postaggregators reporters webapps webviewerwidgets Each subdirectory represents a type of OakVar module. Inside each type subdirectory, another level of subdirectories exist for the modules of the type directory. For example, in reporter module type directory, the following subdirectories may exist, which correspond to the reporter modules in the system. csvreporter excelreporter stdoutreporter textreporter tsvreporter vcfreporter Anatomy of a module Details of a specific module can be shown with ov module info . Let's take a look at the information of stdoutreporter module. ov module info stdoutreporter In the output, the directory where the module is installed can be found in location field. In the directory of stdoutreporter , the following three files will exist. stdoutreporter.md stdoutreporter.py stdoutreporter.yml Among these files, .py and .yml files are the two essential files of any OakVar module. .py file is a Python module file which handles the operation of the module. .yml file is a YAML format file which has the information and the configuration of the module. .md file is a markdown format file which will be displayed on the OakVar web store. Reporter Let's take a look at each of these files. Below is the essential parts of stdoutreporter.yml . title: Standard Output Reporter version: 1.2.0 type: reporter OakVar uses this information to manage modules. Below is stdoutreporter.py . from oakvar import BaseReport class Reporter(BaseReport): def setup (self): if self.args: self.levels_to_write = self.args.get(\"level\") if not self.levels_to_write: self.levels_to_write = ['variant'] def write_preface (self, level): self.level = level def write_header (self, level): line = '#'+'\\t'.join([col['col_name'] for \\ col in self.extracted_cols[level]]) print(line) def write_table_row (self, row): print('\\t'.join([str(v) if v != None else '' \\ for v in list(row)])) stdoutreporter.py does not have all the codes to filter and fetch annotated variants from an OakVar annotation database file. OakVar connects to stdoutreporter.py and calls functions setup , write_preface , write_header , and write_table_row . By defining these functions, different reporter modules can be made. More on these functions are explained in Workflow section. Annotator The essential function for annotator modules is annotator . Below is target.py of target annotation module. from oakvar import BaseAnnotator import sqlite3 class Annotator(BaseAnnotator): def annotate(self, input_data): self.cursor.execute('select rationale, agents_therapy ' + 'from target where gene=\"%s\";'%input_data['hugo']) row = self.cursor.fetchone() if row: out = {'rationale': row[0], 'therapy': row[1]} else: out = None return out annotate function receives input_data which is a dict of a variant, such as {\"uid\": 1834, \"chrom\": \"chr1\", \"pos\": 19834895, \"ref_base\": \"A\", \"alt_base\": \"G\"} OakVar will feed into annotate of an annotator module with variants of the input file, one by one, and excepts a dict of the module's output for each given variant. In the above example, the output is a dict with two keys, rationale and therapy . OakVar will collect the dict s of input variants and feed them to the downstream steps. The two keys rationale and therapy in the above example are the output columns of the module. The output columns of a module should be defined in the module's config ( .yml ) file. target module's config file, target.yml , has the following output columns definition. output_columns: - name: therapy title: Recommended Therapy type: string - name: rationale title: Rationale type: string name , title , and type are essential components of an output column, with name being the same as a key in the output dict by annotate function. OakVar will expect the keys defined as name in output_columns in a module's config file in the return value of annotate function of the module. Once a module's output columns are defined in its config file and the module's annotate function returns a dict with those output columns' name as its keys, OakVar will do the rest to include the module's output in the annotation database and reports. OakVar provides convenience variables to eahc module's annotate function. If a module has data subdirectory and if the subdirectory has an SQLite database file whose name is <module name>.sqlite (thus, in the above example, target/data/target.sqlite ), self.conn and self.cursor are provided as an SQLite database connection and cursor objects. Mapper The essential function for mapper modules is map . A typical mapper modules will be structured as follows. ... class Mapper(BaseMapper): ... def map(self, input_data): ... A mapper module's map function is similar to an annotator module's annotate function, in that it receives a dict of an input variant, which has keys such as uid , chrom , pos , ref_base , and alt_base) and is expected to return an dict of its output. One difference is that its output dict is supposed to have a pre-defined set of keys. First of all, the output dict of map function should have the keys in input_data`. Then, the following keys should be defined as well. coding hugo transcript so cchange achange all_mappings More details will be explained here. Until then, you can take a look at gencode module's gencode.py to know more. Converter The essential function for converter modules is convert_line . A typical converter module will be structured as follows. ... class Converter(BaseConverter): ... def convert_line(self, l): ... More will be explained later. Postaggregator The essential function for postaggregator modules is annotate . A typical postaggregator module will be structured as follows. ... class Postaggregator(BasePostaggregator): ... def annotate(self, input_data): ... More will be explained later. Dependency control Module dependency An OakVar module can depend on other OakVar modules for it to properly function. Let's say module annotator1 uses the output of annotator2 and annotator3 as its input. For annotator1 to properly function, annotator2 and annotator3 should be already installed. This installation requirement is specified in the config file of annotator1 ( annotator1.yml ) as the following: requires: - annotator2 - annotator3 With this in place, when annotator1 is installed with ov module install annotator1 , the two dependency modules also will be installed automatically, if not already present in the system. As mentioned, annotator1 uses the output of annotator2 and annotator3 as its input. This dependency should be defined in annotator1.yml as the following. secondary_inputs: annotator2: {} annotator3: {} With this simple definition, the output of annotate2 and annotate3 will be available as secondary_data variable to the annotate function of annotate1 module. For example, def annotate(self, input_data, secondary_data=None): ... of annotate1.py will have secondary_data[\"annotate2\"] and secondary_data[\"annotate3\"] available. If annotate2.yml has the following output column definition, output_columns: - name: value1 title: Value 1 type: string - name: value2 title: Value 2 type: string annotate1 's annotate function will be able to access those with secondary_data[\"annotator2\"][\"value1\"] and secondary_data[\"annotator2\"][\"value2\"]\" . Finer control of secondary input is possible as follows. For example, the following in annotate1.yml secondary_inputs: annotator2: match_columns: primary: uid secondary: uid use_columns: - value1 will mean that annotator2 output will be available as secondary_data[\"annotator2\"] to the annotate function of annotator1 , that for each variant, the uid field in the output by annotator2 and the uid field in input_data to the annotate function of annotator1 will be match to find the correct secondary_data for the variant to the function, and that only value1 field will be available to the function. PyPI dependency If an OakVar module needs packages from PyPI, such requirement can be specified in the module's yml file. For example, if annotator1 's annotator1.yml has the following, pypi_dependencies: - numpy ov module install annotator1 will automatically perform pip install numpy while installing annotate1 module.","title":"Modules"},{"location":"devguide_modules/#anatomy-of-a-module","text":"Details of a specific module can be shown with ov module info . Let's take a look at the information of stdoutreporter module. ov module info stdoutreporter In the output, the directory where the module is installed can be found in location field. In the directory of stdoutreporter , the following three files will exist. stdoutreporter.md stdoutreporter.py stdoutreporter.yml Among these files, .py and .yml files are the two essential files of any OakVar module. .py file is a Python module file which handles the operation of the module. .yml file is a YAML format file which has the information and the configuration of the module. .md file is a markdown format file which will be displayed on the OakVar web store.","title":"Anatomy of a module"},{"location":"devguide_modules/#reporter","text":"Let's take a look at each of these files. Below is the essential parts of stdoutreporter.yml . title: Standard Output Reporter version: 1.2.0 type: reporter OakVar uses this information to manage modules. Below is stdoutreporter.py . from oakvar import BaseReport class Reporter(BaseReport): def setup (self): if self.args: self.levels_to_write = self.args.get(\"level\") if not self.levels_to_write: self.levels_to_write = ['variant'] def write_preface (self, level): self.level = level def write_header (self, level): line = '#'+'\\t'.join([col['col_name'] for \\ col in self.extracted_cols[level]]) print(line) def write_table_row (self, row): print('\\t'.join([str(v) if v != None else '' \\ for v in list(row)])) stdoutreporter.py does not have all the codes to filter and fetch annotated variants from an OakVar annotation database file. OakVar connects to stdoutreporter.py and calls functions setup , write_preface , write_header , and write_table_row . By defining these functions, different reporter modules can be made. More on these functions are explained in Workflow section.","title":"Reporter"},{"location":"devguide_modules/#annotator","text":"The essential function for annotator modules is annotator . Below is target.py of target annotation module. from oakvar import BaseAnnotator import sqlite3 class Annotator(BaseAnnotator): def annotate(self, input_data): self.cursor.execute('select rationale, agents_therapy ' + 'from target where gene=\"%s\";'%input_data['hugo']) row = self.cursor.fetchone() if row: out = {'rationale': row[0], 'therapy': row[1]} else: out = None return out annotate function receives input_data which is a dict of a variant, such as {\"uid\": 1834, \"chrom\": \"chr1\", \"pos\": 19834895, \"ref_base\": \"A\", \"alt_base\": \"G\"} OakVar will feed into annotate of an annotator module with variants of the input file, one by one, and excepts a dict of the module's output for each given variant. In the above example, the output is a dict with two keys, rationale and therapy . OakVar will collect the dict s of input variants and feed them to the downstream steps. The two keys rationale and therapy in the above example are the output columns of the module. The output columns of a module should be defined in the module's config ( .yml ) file. target module's config file, target.yml , has the following output columns definition. output_columns: - name: therapy title: Recommended Therapy type: string - name: rationale title: Rationale type: string name , title , and type are essential components of an output column, with name being the same as a key in the output dict by annotate function. OakVar will expect the keys defined as name in output_columns in a module's config file in the return value of annotate function of the module. Once a module's output columns are defined in its config file and the module's annotate function returns a dict with those output columns' name as its keys, OakVar will do the rest to include the module's output in the annotation database and reports. OakVar provides convenience variables to eahc module's annotate function. If a module has data subdirectory and if the subdirectory has an SQLite database file whose name is <module name>.sqlite (thus, in the above example, target/data/target.sqlite ), self.conn and self.cursor are provided as an SQLite database connection and cursor objects.","title":"Annotator"},{"location":"devguide_modules/#mapper","text":"The essential function for mapper modules is map . A typical mapper modules will be structured as follows. ... class Mapper(BaseMapper): ... def map(self, input_data): ... A mapper module's map function is similar to an annotator module's annotate function, in that it receives a dict of an input variant, which has keys such as uid , chrom , pos , ref_base , and alt_base) and is expected to return an dict of its output. One difference is that its output dict is supposed to have a pre-defined set of keys. First of all, the output dict of map function should have the keys in input_data`. Then, the following keys should be defined as well. coding hugo transcript so cchange achange all_mappings More details will be explained here. Until then, you can take a look at gencode module's gencode.py to know more.","title":"Mapper"},{"location":"devguide_modules/#converter","text":"The essential function for converter modules is convert_line . A typical converter module will be structured as follows. ... class Converter(BaseConverter): ... def convert_line(self, l): ... More will be explained later.","title":"Converter"},{"location":"devguide_modules/#postaggregator","text":"The essential function for postaggregator modules is annotate . A typical postaggregator module will be structured as follows. ... class Postaggregator(BasePostaggregator): ... def annotate(self, input_data): ... More will be explained later.","title":"Postaggregator"},{"location":"devguide_modules/#dependency-control","text":"","title":"Dependency control"},{"location":"devguide_modules/#module-dependency","text":"An OakVar module can depend on other OakVar modules for it to properly function. Let's say module annotator1 uses the output of annotator2 and annotator3 as its input. For annotator1 to properly function, annotator2 and annotator3 should be already installed. This installation requirement is specified in the config file of annotator1 ( annotator1.yml ) as the following: requires: - annotator2 - annotator3 With this in place, when annotator1 is installed with ov module install annotator1 , the two dependency modules also will be installed automatically, if not already present in the system. As mentioned, annotator1 uses the output of annotator2 and annotator3 as its input. This dependency should be defined in annotator1.yml as the following. secondary_inputs: annotator2: {} annotator3: {} With this simple definition, the output of annotate2 and annotate3 will be available as secondary_data variable to the annotate function of annotate1 module. For example, def annotate(self, input_data, secondary_data=None): ... of annotate1.py will have secondary_data[\"annotate2\"] and secondary_data[\"annotate3\"] available. If annotate2.yml has the following output column definition, output_columns: - name: value1 title: Value 1 type: string - name: value2 title: Value 2 type: string annotate1 's annotate function will be able to access those with secondary_data[\"annotator2\"][\"value1\"] and secondary_data[\"annotator2\"][\"value2\"]\" . Finer control of secondary input is possible as follows. For example, the following in annotate1.yml secondary_inputs: annotator2: match_columns: primary: uid secondary: uid use_columns: - value1 will mean that annotator2 output will be available as secondary_data[\"annotator2\"] to the annotate function of annotator1 , that for each variant, the uid field in the output by annotator2 and the uid field in input_data to the annotate function of annotator1 will be match to find the correct secondary_data for the variant to the function, and that only value1 field will be available to the function.","title":"Module dependency"},{"location":"devguide_modules/#pypi-dependency","text":"If an OakVar module needs packages from PyPI, such requirement can be specified in the module's yml file. For example, if annotator1 's annotator1.yml has the following, pypi_dependencies: - numpy ov module install annotator1 will automatically perform pip install numpy while installing annotate1 module.","title":"PyPI dependency"},{"location":"devguide_workflows/","text":"There are a few workflows of using OakVar modules. ov run ov report ov gui As mentioned, there are three workflows of using modules in OakVar. ov run ov report ov gui ov run When ov run is called, OakVar imports and executes modules in the following manner. input | recognizes input files' format with | converter modules' check_format function v converter module's convert_line function v mapper module's map function | imports annotator modules according to | -a option v annotator modules' annotate function | import postaggregator modules according to | -p option as well as default postaggregator | modules v postaggregator modules' annotate function | import reporter modules according to | -t option v reporter modules' write_preface, write_header, write_table_row functions | v report files ov report When ov report is called, OakVar imports and executes modules in the following manner. annotation database file | import reporter modules accorging to | -t option v reporter modules' write_preface, write_header, write_table_row functions | v report files ov gui Will be discussed later.","title":"Workflows"},{"location":"devguide_workflows/#ov-run","text":"When ov run is called, OakVar imports and executes modules in the following manner. input | recognizes input files' format with | converter modules' check_format function v converter module's convert_line function v mapper module's map function | imports annotator modules according to | -a option v annotator modules' annotate function | import postaggregator modules according to | -p option as well as default postaggregator | modules v postaggregator modules' annotate function | import reporter modules according to | -t option v reporter modules' write_preface, write_header, write_table_row functions | v report files","title":"ov run"},{"location":"devguide_workflows/#ov-report","text":"When ov report is called, OakVar imports and executes modules in the following manner. annotation database file | import reporter modules accorging to | -t option v reporter modules' write_preface, write_header, write_table_row functions | v report files","title":"ov report"},{"location":"devguide_workflows/#ov-gui","text":"Will be discussed later.","title":"ov gui"},{"location":"gui/","text":"OakVar's graphical user interface (GUI) is launched by ov gui A web server will be started on the terminal and your default web browser will open a new tab, which will show the graphical user interface of OakVar. The log output of the web server will be at wcravat.log file under conf_dir shown by ov system config . Also, ov gui --debug will display any error the server encounters on the terminal as well. OakVar GUI has two tabs, Jobs and Store . Jobs In Jobs tab of OakVar GUI, you can submit jobs and launch interactive result viewer for individual jobs. Store In Store tab of OakVar GUI, you can install and uninstall OakVar modules as well as explore the details of each module. OakVar's web store brings OakVar's own modules as well as OpenCRAVAT's modules. Result Viewer ov gui with a path to an OakVar result SQLite database file will launch the OakVar result viewer. For example, ov gui sample_1.vcf.sqlite will launch the OakVar result viewer on the analysis data in sample_1.vcf.sqlite . Just-DNA-Seq group wrote a very nice tutorial on using OakVar GUI. Please refer to their doc for more details of using OakVar GUI.","title":"Graphical user interface"},{"location":"gui/#jobs","text":"In Jobs tab of OakVar GUI, you can submit jobs and launch interactive result viewer for individual jobs.","title":"Jobs"},{"location":"gui/#store","text":"In Store tab of OakVar GUI, you can install and uninstall OakVar modules as well as explore the details of each module. OakVar's web store brings OakVar's own modules as well as OpenCRAVAT's modules.","title":"Store"},{"location":"gui/#result-viewer","text":"ov gui with a path to an OakVar result SQLite database file will launch the OakVar result viewer. For example, ov gui sample_1.vcf.sqlite will launch the OakVar result viewer on the analysis data in sample_1.vcf.sqlite . Just-DNA-Seq group wrote a very nice tutorial on using OakVar GUI. Please refer to their doc for more details of using OakVar GUI.","title":"Result Viewer"},{"location":"install_modules/","text":"Installing through OakVar Store The OakVar Store is where OakVar's modules are registered, found, and distributed. If you used OpenCRAVAT, OpenCRAVAT's modules are also available through OakVar Store if there is no updated OakVar version of the same module exists. To know which modules are available through the OakVar Store, do ov module ls -a This will list the OakVar modules available through the OakVar Store. To know more details of a specific module, do ov module info module_name # module_name such as clinvar To install modules, do ov module install module_name [module_name] ... A regular expression can be given as module_name . Thus, ov module install clin.* will install all modules the name of which starts with clin . Installing through GitHub ov module install can accept a GitHub URL as module_name . Thus, OakVar can now install custom modules directly from GitHub. It is as easy as simply giving the URL of the folder of the module on GitHub to ov module install . Let's say you have a custom module hosted on the dev branch of your GitHub repo yourorganization/yourrepo in the following folder: https://github.com/yourorganization/yourrepo/ oakvar_modules/ annotators/ awesomeannotator/ awssomeannotator.py awssomeannotator.yml awssomeannotator.md data/ awesomeannotator.sqlite Your colleagues can install awesomeannotator module with the following command. ov module install \\ https://github.com/yourorganization/yourrepo/\\ tree/dev/oakvar_modules/annotators/awssomeannotator will download the content of only the annotator folder in the dev branch of the repository, figure out that the module is an annotator , and put the awesomeannotator module under the appropriate annotators category folder inside your system's OakVar modules root directory. This way, your custom module under development can be easily shared with your colleagues.","title":"Modules"},{"location":"install_modules/#installing-through-oakvar-store","text":"The OakVar Store is where OakVar's modules are registered, found, and distributed. If you used OpenCRAVAT, OpenCRAVAT's modules are also available through OakVar Store if there is no updated OakVar version of the same module exists. To know which modules are available through the OakVar Store, do ov module ls -a This will list the OakVar modules available through the OakVar Store. To know more details of a specific module, do ov module info module_name # module_name such as clinvar To install modules, do ov module install module_name [module_name] ... A regular expression can be given as module_name . Thus, ov module install clin.* will install all modules the name of which starts with clin .","title":"Installing through OakVar Store"},{"location":"install_modules/#installing-through-github","text":"ov module install can accept a GitHub URL as module_name . Thus, OakVar can now install custom modules directly from GitHub. It is as easy as simply giving the URL of the folder of the module on GitHub to ov module install . Let's say you have a custom module hosted on the dev branch of your GitHub repo yourorganization/yourrepo in the following folder: https://github.com/yourorganization/yourrepo/ oakvar_modules/ annotators/ awesomeannotator/ awssomeannotator.py awssomeannotator.yml awssomeannotator.md data/ awesomeannotator.sqlite Your colleagues can install awesomeannotator module with the following command. ov module install \\ https://github.com/yourorganization/yourrepo/\\ tree/dev/oakvar_modules/annotators/awssomeannotator will download the content of only the annotator folder in the dev branch of the repository, figure out that the module is an annotator , and put the awesomeannotator module under the appropriate annotators category folder inside your system's OakVar modules root directory. This way, your custom module under development can be easily shared with your colleagues.","title":"Installing through GitHub"},{"location":"install_system/","text":"Installation Install OakVar. pip install oakvar Then, set up OakVar. ov system setup Note for open-cravat users OakVar does not share system files with nor transfer system configuration from open-cravat anymore. OakVar's default modules directory is different and oc will still call open-cravat and only ov will invoke OakVar. OakVar is still backward-compatible with open-cravat modules. If you have been using open-cravat and want to use open-cravat modules with OakVar, you can do so by setting OakVar modules directory to that of open-cravat with ov system md command. Please keep in mind that OakVar has its own updated versions for some of open-cravat modules, so if you are sharing the same modules directory between OakVar and open-cravat, ov module update may break oc-compatibility of some of the updated modules. Setup ov system setup will set up OakVar with sane defaults. Setup process can be customized with a setup file or environment variables, which can be useful in automated deployment. Setup with a file A setup file in yaml format can be used. System configuration fields which are missing in the setup file will be filled with sane defaults. Setup with a file with custom locations for modules and logs can be done as ov system setup -f setup.yaml where setup.yaml is modules_dir: ~/oakvar_modules logs_dir: ~/oakvar_logs Setup with environment variables All system configuration fields can be overridden with environment variables. To override a system config field, set the environment variable OV_ + upper-cased field name to a desired value. For example, System configuration field Environmental variable sys_conf_path OV_SYS_CONF_PATH root_dir OV_ROOT_DIR modules_dir OV_MODULES_DIR log_dir OV_LOG_DIR jobs_dir OV_JOBS_DIR conf_dir OV_CONF_DIR gui_port OV_GUI_PORT The custom setup in the previous section can be done using environmental variables as export OV_MODULES_DIR=~/oakvar_modules export OV_LOGS_DIR=~/oakvar_logs ov system setup Another example is installing system files in a custom directory. export OV_ROOT_DIR=/data/oakvar ov system setup This will install OakVar system files at /data/oakvar . Using environmental variablse for setup can be useful in deploying OakVar with Docker containers. Clean setup If you experience any problem and want to do clean installation of OakVar, ov system setup --clean provides such clean installation. It will reset the system and user configuration files. --clean still will not delete modules , jobs , logs , and conf folders. modules have downloaded modules and users should manually delete this folder if they really want, because this folder can take a lot of time to recreate. jobs , logs , and conf folders have just contents.","title":"System"},{"location":"install_system/#installation","text":"Install OakVar. pip install oakvar Then, set up OakVar. ov system setup","title":"Installation"},{"location":"install_system/#note-for-open-cravat-users","text":"OakVar does not share system files with nor transfer system configuration from open-cravat anymore. OakVar's default modules directory is different and oc will still call open-cravat and only ov will invoke OakVar. OakVar is still backward-compatible with open-cravat modules. If you have been using open-cravat and want to use open-cravat modules with OakVar, you can do so by setting OakVar modules directory to that of open-cravat with ov system md command. Please keep in mind that OakVar has its own updated versions for some of open-cravat modules, so if you are sharing the same modules directory between OakVar and open-cravat, ov module update may break oc-compatibility of some of the updated modules.","title":"Note for open-cravat users"},{"location":"install_system/#setup","text":"ov system setup will set up OakVar with sane defaults. Setup process can be customized with a setup file or environment variables, which can be useful in automated deployment.","title":"Setup"},{"location":"install_system/#setup-with-a-file","text":"A setup file in yaml format can be used. System configuration fields which are missing in the setup file will be filled with sane defaults. Setup with a file with custom locations for modules and logs can be done as ov system setup -f setup.yaml where setup.yaml is modules_dir: ~/oakvar_modules logs_dir: ~/oakvar_logs","title":"Setup with a file"},{"location":"install_system/#setup-with-environment-variables","text":"All system configuration fields can be overridden with environment variables. To override a system config field, set the environment variable OV_ + upper-cased field name to a desired value. For example, System configuration field Environmental variable sys_conf_path OV_SYS_CONF_PATH root_dir OV_ROOT_DIR modules_dir OV_MODULES_DIR log_dir OV_LOG_DIR jobs_dir OV_JOBS_DIR conf_dir OV_CONF_DIR gui_port OV_GUI_PORT The custom setup in the previous section can be done using environmental variables as export OV_MODULES_DIR=~/oakvar_modules export OV_LOGS_DIR=~/oakvar_logs ov system setup Another example is installing system files in a custom directory. export OV_ROOT_DIR=/data/oakvar ov system setup This will install OakVar system files at /data/oakvar . Using environmental variablse for setup can be useful in deploying OakVar with Docker containers.","title":"Setup with environment variables"},{"location":"install_system/#clean-setup","text":"If you experience any problem and want to do clean installation of OakVar, ov system setup --clean provides such clean installation. It will reset the system and user configuration files. --clean still will not delete modules , jobs , logs , and conf folders. modules have downloaded modules and users should manually delete this folder if they really want, because this folder can take a lot of time to recreate. jobs , logs , and conf folders have just contents.","title":"Clean setup"},{"location":"overview/","text":"Modular OakVar is a platform for genomic variant analyses. By platform, we mean that OakVar is modular. Modules written in Python are the building blocks of OakVar. OakVar achieves its functions by orchestrating such modules. OakVar has the following core functionality: Annotation Query Serve applications Visualize Annotation Annotation is adding additional information to a variant. A certain variant may have a clinical consequence such as a genetic disease or a meaning such as being rarely observed in a population. There are many sources of such annotation, and manually finding the annotation from these many sources for many variants can be laborious and daunting. OakVar automates this annotation work by: Loop over variants Standardize annotation sources Manage installation of annotation sources Organize the annotation from different sources by variant The main OakVar command for annotation is ov run . For example, the following command will annotate the variants in a VCF file, input.vcf , with annotation sources ClinVar and COSMIC and generate an annotated VCF file, annotated.vcf as well as a database file, annotated.sqlite . ov module install clinvar # if clinvar module is not already installed. ov run input.vcf -a clinvar cosmic -t vcf -n annotated Query Once variants are annotated, they can be filtered by their annotation, for example to know if a sample has clinically relevant variants or not. OakVar stores annotated variants as a database, and thus variants annotated with OakVar can be filtered with SQL queries. OakVar provides a standard mechanism to query variants regardless of their annotation sources. The main OakVar command for querying variants is ov report . For example, the following command will filter the variants in annotated.sqlite with the filter set defined in filter.json and produce a VCF file of filtered variants, filtered.vcf . ov report annotated.sqlite -f filter.json -s filtered -t vcf Query options can be given to ov run as well. The following command will generate the same annotated.sqlite with annotated variants, but annotated.vcf will already have annotated and filtered variants. ov run input.vcf -a clinvar cosmic -t vcf -n annotated -f filter.json Visualize OakVar comes with a graphical user interface. ov gui launches a job and store management web app by default, and also works as the entry point for OakVar's web apps. Applications Most common way of using OakVar is the input-to-output workflow using ov run and ov report . However, any Python-based program can access the variants annotated with OakVar since OakVar is a Python library as well. This aspect of OakVar is being actively developed and streamlined. OakVar comes with two built-in web applications - one for job submission and module management and the other for exploring annotation result, as well as one installable web application for exploring the details of a single variant. Check back this page later for exciting future development in this area.","title":"Overview"},{"location":"overview/#modular","text":"OakVar is a platform for genomic variant analyses. By platform, we mean that OakVar is modular. Modules written in Python are the building blocks of OakVar. OakVar achieves its functions by orchestrating such modules. OakVar has the following core functionality: Annotation Query Serve applications Visualize","title":"Modular"},{"location":"overview/#annotation","text":"Annotation is adding additional information to a variant. A certain variant may have a clinical consequence such as a genetic disease or a meaning such as being rarely observed in a population. There are many sources of such annotation, and manually finding the annotation from these many sources for many variants can be laborious and daunting. OakVar automates this annotation work by: Loop over variants Standardize annotation sources Manage installation of annotation sources Organize the annotation from different sources by variant The main OakVar command for annotation is ov run . For example, the following command will annotate the variants in a VCF file, input.vcf , with annotation sources ClinVar and COSMIC and generate an annotated VCF file, annotated.vcf as well as a database file, annotated.sqlite . ov module install clinvar # if clinvar module is not already installed. ov run input.vcf -a clinvar cosmic -t vcf -n annotated","title":"Annotation"},{"location":"overview/#query","text":"Once variants are annotated, they can be filtered by their annotation, for example to know if a sample has clinically relevant variants or not. OakVar stores annotated variants as a database, and thus variants annotated with OakVar can be filtered with SQL queries. OakVar provides a standard mechanism to query variants regardless of their annotation sources. The main OakVar command for querying variants is ov report . For example, the following command will filter the variants in annotated.sqlite with the filter set defined in filter.json and produce a VCF file of filtered variants, filtered.vcf . ov report annotated.sqlite -f filter.json -s filtered -t vcf Query options can be given to ov run as well. The following command will generate the same annotated.sqlite with annotated variants, but annotated.vcf will already have annotated and filtered variants. ov run input.vcf -a clinvar cosmic -t vcf -n annotated -f filter.json","title":"Query"},{"location":"overview/#visualize","text":"OakVar comes with a graphical user interface. ov gui launches a job and store management web app by default, and also works as the entry point for OakVar's web apps.","title":"Visualize"},{"location":"overview/#applications","text":"Most common way of using OakVar is the input-to-output workflow using ov run and ov report . However, any Python-based program can access the variants annotated with OakVar since OakVar is a Python library as well. This aspect of OakVar is being actively developed and streamlined. OakVar comes with two built-in web applications - one for job submission and module management and the other for exploring annotation result, as well as one installable web application for exploring the details of a single variant. Check back this page later for exciting future development in this area.","title":"Applications"},{"location":"register/","text":"You can publish your OakVar modules to the OakVar store with OakVar command-line interface. For example, let's say you made an awesome OakVar annotation module named awesome and wants to share it with the world. You can do this in three steps. ov module pack awesome This will create one or two files, depending whether your module has data folder in it or not. Your module's code will be packed into awesome__<version>__code.zip where version is the version number defined in awesome.yml file in your module's directory, and if your module has data subdirectory, awesome__<version>__data.zip also will be created. If your module is bigger than 1GB, --split option can be given. This will split the code and the data of your module into zip part files of 1GB each. For example, if awesome module is 2.5GB big and most of the size is from its data, ov module pack awesome --split will produce the following files. awesome__1.0.0__code.zip000 awesome__1.0.0__data.zip000 awesome__1.0.0__data.zip001 awesome__1.0.0__data.zip002 Then, upload these zip files to somewhere people can download. Using their URLs, ov store register awesome --code-url ... --data-url ... will register your module in the OakVar store. --data-url is needed only if your module produced a data zip file. If you have many split zip files, -f option can be given with a YAML format file with code and data URLs. For example, ov store register awesome -f urls.txt with urls.txt of the following content code_url: - https://dropbox.com/xxxxxxxx/awesome__1.0.0__code.zip000 data_url: - https://dropbox.com/xxxxxxxx/awesome__1.0.0__data.zip000 - https://dropbox.com/xxxxxxxx/awesome__1.0.0__data.zip001 - https://dropbox.com/xxxxxxxx/awesome__1.0.0__data.zip002 will register the module. This way, you have total control of your module's publication. You can just delete the module zip files from where you stored them and OakVar store will automatically deregister those deleted versions. If you move the module zip files to new locations you can just register them again with new URLs.","title":"Publishing your module"},{"location":"tutorial/","text":"Installation First, let's install OakVar. pip install oakvar Setup Then, we set up OakVar, including configuration files, system folders, an OakVar account, and OakVar store cache files. ov system setup Check system configuration How OakVar has been set up can be viewed with ov config system command. ov config system publish_url: https://store.oakvar.com store_url: https://store.oakvar.com ... default_assembly: hg38 sys_conf_path: /Users/Shared/oakvar/conf/system.yml root_dir: /Users/Shared/oakvar modules_dir: /Users/Shared/oakvar/modules conf_dir: /Users/Shared/oakvar/conf jobs_dir: /Users/Shared/oakvar/jobs log_dir: /Users/Shared/oakvar/logs modules_dir is where OakVar modules for conversion, mapping, annotation, and reporting as well as OakVar applications are stored. Install ClinVar annotation module In this tutorial, we will annotate variants with ClinVar . To do so, we install the ClinVar module. ov module install clinvar Uninstall a module Just to practice uninstalling a module, we'll install and then uninstall BioGRID . ov module install biogrid ov module uninstall biogrid Create an example input Next, we need some variants to annotate. OakVar has a built-in variant file for this purpose. ov new exampleinput This will create an example input file, exampleinput , in the current directory. Run an annotation job Now, we annotate the example input file with ClinVar and then create a result VCF file with annotated variants. -a option controls annotation sources and -t option report formats. ov run exampleinput -a clinvar -t vcf This will create exampleinuput.vcf which will have the input variants annotated with ClinVar. Additionally, exampleinput.sqlite will be created. This file is a SQLite database file with annotated variants. Examine the annotated variants Let's examine the annotated variants in the previous step. ov report is used to show or generate the output of annotated variants. ov report exampleinput.sqlite -t stdout This will print out the annotated variants to the screen. -t stdout tells ov report to use stdoutreporter module, which is a reporter module and will receive annotated variants, variant by variant, from ov report and convert it to the standard output of the terminal. Generate an Excel report of annotated variants There are more reporter modules. excelreporter , an Excel format reporting module is included in OakVar by default. -s option defines the file name of the report file except the extension. ov report exampleinput.sqlite -t excel -s annotated This will generate annotated.xlsx file with annotated variants. Visualize annotated variants OakVar comes with a couple of embedded web applications, for graphical user interface-based operation of OakVar. Let's explore the annotated variants on a web browser. ov gui exampleinput.sqlite This will launch an interactive result viewer for the analysis job done in the previous section. Click the tabs and look around the tables with annotated variants and the widgets in each tab. Filter tab has a customizable filter section. Click the brown + button at the bottom left corner to add and set up filter criteria, and click Apply Filter button to load filtered variants. ov gui will launch a graphical user interface for managing analysis jobs and modules. Click VCF button to use an example input and click Annotate button to run an annotation job. The new job will show on the job table. Installing and uninstalling modules can be managed on Store tab.","title":"Tutorial"},{"location":"tutorial/#installation","text":"First, let's install OakVar. pip install oakvar","title":"Installation"},{"location":"tutorial/#setup","text":"Then, we set up OakVar, including configuration files, system folders, an OakVar account, and OakVar store cache files. ov system setup","title":"Setup"},{"location":"tutorial/#check-system-configuration","text":"How OakVar has been set up can be viewed with ov config system command. ov config system publish_url: https://store.oakvar.com store_url: https://store.oakvar.com ... default_assembly: hg38 sys_conf_path: /Users/Shared/oakvar/conf/system.yml root_dir: /Users/Shared/oakvar modules_dir: /Users/Shared/oakvar/modules conf_dir: /Users/Shared/oakvar/conf jobs_dir: /Users/Shared/oakvar/jobs log_dir: /Users/Shared/oakvar/logs modules_dir is where OakVar modules for conversion, mapping, annotation, and reporting as well as OakVar applications are stored.","title":"Check system configuration"},{"location":"tutorial/#install-clinvar-annotation-module","text":"In this tutorial, we will annotate variants with ClinVar . To do so, we install the ClinVar module. ov module install clinvar","title":"Install ClinVar annotation module"},{"location":"tutorial/#uninstall-a-module","text":"Just to practice uninstalling a module, we'll install and then uninstall BioGRID . ov module install biogrid ov module uninstall biogrid","title":"Uninstall a module"},{"location":"tutorial/#create-an-example-input","text":"Next, we need some variants to annotate. OakVar has a built-in variant file for this purpose. ov new exampleinput This will create an example input file, exampleinput , in the current directory.","title":"Create an example input"},{"location":"tutorial/#run-an-annotation-job","text":"Now, we annotate the example input file with ClinVar and then create a result VCF file with annotated variants. -a option controls annotation sources and -t option report formats. ov run exampleinput -a clinvar -t vcf This will create exampleinuput.vcf which will have the input variants annotated with ClinVar. Additionally, exampleinput.sqlite will be created. This file is a SQLite database file with annotated variants.","title":"Run an annotation job"},{"location":"tutorial/#examine-the-annotated-variants","text":"Let's examine the annotated variants in the previous step. ov report is used to show or generate the output of annotated variants. ov report exampleinput.sqlite -t stdout This will print out the annotated variants to the screen. -t stdout tells ov report to use stdoutreporter module, which is a reporter module and will receive annotated variants, variant by variant, from ov report and convert it to the standard output of the terminal.","title":"Examine the annotated variants"},{"location":"tutorial/#generate-an-excel-report-of-annotated-variants","text":"There are more reporter modules. excelreporter , an Excel format reporting module is included in OakVar by default. -s option defines the file name of the report file except the extension. ov report exampleinput.sqlite -t excel -s annotated This will generate annotated.xlsx file with annotated variants.","title":"Generate an Excel report of annotated variants"},{"location":"tutorial/#visualize-annotated-variants","text":"OakVar comes with a couple of embedded web applications, for graphical user interface-based operation of OakVar. Let's explore the annotated variants on a web browser. ov gui exampleinput.sqlite This will launch an interactive result viewer for the analysis job done in the previous section. Click the tabs and look around the tables with annotated variants and the widgets in each tab. Filter tab has a customizable filter section. Click the brown + button at the bottom left corner to add and set up filter criteria, and click Apply Filter button to load filtered variants. ov gui will launch a graphical user interface for managing analysis jobs and modules. Click VCF button to use an example input and click Annotate button to run an annotation job. The new job will show on the job table. Installing and uninstalling modules can be managed on Store tab.","title":"Visualize annotated variants"},{"location":"vcf2vcf/","text":"With OakVar v2.5.0 and later, a fast-track annotation workflow, vcf2vcf , is available. The speed-up by this workflow can be an order of magnitude compared to previous versions, depending on the number of samples. For example, mapping the variants in the chromosome 20 of the 1000 Genomes Project data took about 10 minutes with --vcf2vcf in our test system. With ClinVar annotation added, about 15 minutes. The condition to use this workflow is: Input file format is Variant Call Format (VCF). Output file format is also VCF. Annotation SQLite database files are not needed. To use vcf2vcf , just add --vcf2vcf to ov run . The output format will be always VCF, so -t option is not necessary. For example, ov run input.vcf --vcf2vcf -a clinvar will read input.vcf and generate input.vcf.vcf with ClinVar annotation as well as GENCODE gene mapping. ov run input.vcf --vcf2vcf -a clinvar -n annotated will generate annotated.vcf as output, due to -n option.","title":"VCF2VCF"}]}